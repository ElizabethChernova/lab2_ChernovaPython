#1. Створити змінні, що посилаються на два цілих числа, що однакові за значенням,
# де значення належить проміжку від -5 до 256. Перевірте, чи будуть ці змінні рівні
# тільки за значенням або ж ще будуть посилатися на один і той самий обʼєкт в памʼяті?
# Наведіть код та дайте текстову відповідь нижче.
print("--------------------1-----------------")
num1 = 42
num2 = 42

are_same_object = num1 is num2

print(f"Число 1: {num1}")
print(f"Число 2: {num2}")
print(f"Числа рівні за значенням: {num1 == num2}")
print(f"Числа посилаються на один і той самий об'єкт в пам'яті: {are_same_object}")
#Так, змінні посиляються на один і той самий об'єкт
#2. За допомогою якої функції можна перевірити належність змінної до вказаного типу даних
# (напр. чи змінна True посилається на значення булевого та цілочисленого типу)?
print("--------------------2-----------------")
my_variable_int = 45
my_var_bool = False
is_boolean1 = isinstance(my_variable_int, bool)

is_integer1 = isinstance(my_variable_int, int)

is_boolean2 = isinstance(my_var_bool, bool)

is_integer2 = isinstance(my_var_bool, int)

print(f"Моя змінна: {my_variable_int}")
print(f"Чи змінна належить до булевого типу: {is_boolean1}")
print(f"Чи змінна належить до цілочисельного типу: {is_integer1}")

print(f"Моя змінна: {my_var_bool}")
print(f"Чи змінна належить до булевого типу: {is_boolean2}")
print(f"Чи змінна належить до цілочисельного типу: {is_integer2}")
#Відповідь: isinstance()
#3. Створити дві змінні, що посилаються на будь-які ціле число та число з рухомою комою та
# продемонструвати такі арифметичні операції: додавання, віднімання, ділення, множення,
# ділення без залишку, ділення по модулю, приведення до ступеню. Всі результати операцій вивести на екран.
int_vaar = 8
fl_var = 4.5
print("--------------------3-----------------")
print(f"Додавання: {(int_vaar + fl_var)}")
print(f"Віднімання: {(int_vaar - fl_var)}")
print(f"Ділення: {(int_vaar / fl_var)}")
print(f"Множення: {(int_vaar * fl_var)}")
print(f"Ділення без залишку: {(int_vaar // fl_var)}")
print(f"Ділення по модулю: {(int_vaar % fl_var)}")
print(f"Підняття до ступеня: {(int_vaar ** 2)}")
#4. Використовуючи змінні з вправи 3, продемонструйте механізм явного перетворення типів, де числа
# з рухомою комою перетворюються на цілі числа. Також визначте змінну, що посилається на значення
# булевого типу і спробуйте явно привести її до цілого числа.
print("--------------------4-----------------")
int_from_float = int(fl_var)
print(f"Ціле число з числа з рухомою комою: {int_from_float}")

bool_variable = True
int_from_bool = int(bool_variable)
print(f"Ціле число з булевого значення: {int_from_bool}")
#5. Створити пустий рядок двома різними способами.
print("--------------------5-----------------")
empty_string1 = str()
empty_string2 = ""
print(f"Пустий рядок 1: '{empty_string1}'")
print(f"Пустий рядок 2: '{empty_string2}'")
#6. Створити рядок з апострофом. Зробити його сирим. Вивести обидва рядка на екран.
print("--------------------6-----------------")
string_with_apostrophe = 'This is an apostrophe: \''
raw_string = r'This is a raw string with an apostrophe: \''
print(string_with_apostrophe)
print(raw_string)

#7. Створити змінну, що буде посилатися на Ваше прізвище латинкою. Створити форматований рядок,
# який буде мати вигляд "My surname is ______", де на місці нижніх підкреслень буде Ваше прізвище
# зі змінної.
print("--------------------7-----------------")
surname = "Chernova"
formatted_string = f"My surname is {surname}"
print(formatted_string)
#8. Маючи рядок "My dog is crazy." перетворити його на список ["my", "dog", "is", "crazy"]
print("--------------------8-----------------")
my_string_about_dog = "My dog is crazy."

dog_word_list = my_string_about_dog.split()
print(dog_word_list)

#9. Створити список двома різними за синтаксисом способами. За допомогою вбудованої функції
# обчисліть довжину одного з них.

print("--------------------9-----------------")
list_1 = [1, 2, 3, 4, 5]
list_2 = list(range(5, 10))

length_of_list = len(list_1)
print(f"Список1: {list_1}")
print(f"Список2: {list_2}")
print(f"Довжина списку: {length_of_list}")
#10. Створіть два списка та за допомогою спеціального методу додайте другий з них в якості
# останнього елемента першого.
print("--------------------10----------------")
list1 = [1, 2, 3]
list2 = [4, 5, 6]
print(f"Список1: {list1}")
print(f"Список2: {list2}")
list1.extend(list2)
print("Об'єднаний список:", list1)
#11. Створіть список, де елементами цього списку також є списки. Отримай перший елемент з
# останнього рядка та виведи значення на екран.
print("--------------------11-----------------")
nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

value = nested_list[-1][0]
print("Значення з останнього рядка:", value)
#12. Створіть список з десяти елементів різного типу. Отримайте всі елементи, окрім двох перших
# та двох останніх та збережіть їх в новій змінній.
print("--------------------12-----------------")
mixed_list = [1, "two", 3.0, [4, 5], (6, 7), {"eight": 8}, True, None, 9, 10]

new_list = mixed_list[2:-2]
print("Старий список:", mixed_list)
print("Новий список:", new_list)
#14. Створити кортеж з один елементом.
print("--------------------14-----------------")
single_element_tuple = (42,)
print(single_element_tuple)
#15. Порівняйте список та кортеж. Назвіть схожості та відмінності, випадки використання.
# Створення списку
print("--------------------15-----------------")
my_list = [1, 2, 3, 'hello', [4, 5]]

# Створення кортежу
my_tuple = (1, 2, 3, 'hello', (4, 5))

# Схожості
# 1. Обидва є ітерабельними
for element in my_list:
    print(element)
print("-----")
for element in my_tuple:
    print(element)

# 2. Можуть містити елементи різних типів даних
mixed_data_list = [1, 'two', 3.0, [4, 5]]
mixed_data_tuple = (1, 'two', 3.0, (4, 5))

# 3. Доступ до елементів за допомогою індексів
print(my_list[3])
print(my_tuple[3])

# Відмінності
# 1. Змінюваність
my_list[0] = 'new value'
# my_tuple[0] = 'new value'  # Помилка - кортеж незмінюваний

# 2. Синтаксис створення
new_list = [x for x in range(5)]
new_tuple = tuple(x for x in range(5))

# 3. Застосування в ключах словників
#dictionary_with_list = {[1, 2]: 'value'}  # Помилка - список не може бути ключем у словнику
dictionary_with_tuple = {(1, 2): 'value'}

# Випадки використання
# Список використовуємо, коли:
# - Потрібна можливість змінювати дані.
# - Дані пов'язані з послідовністю чи порядком.

# Кортеж використовуємо, коли:
# - Дані не повинні змінюватися під час виконання програми.
# - Потрібна оптимізація для читання.
# - Використовуються як ключі у словниках.

# Приклад модифікації
my_list.append(6)
# my_tuple.append(6)          # Помилка - кортеж незмінюваний

print("Modified List:", my_list)
print("Original Tuple:", my_tuple)
print("Mixed Data List:", mixed_data_list)
print("Mixed Data Tuple:", mixed_data_tuple)
print("New List:", new_list)
print("New Tuple:", new_tuple)
print("Dictionary with Tuple:", dictionary_with_tuple)

#16. Створіть кортеж з 11ти елементів чисел з рухомою комою та отримайте кожен парний за
# індексом елемент в зворотньому порядку. Наприклад, маючи (1.2, 2.3, 3.3, 4.3, 5.3, 6.3, 7.3,
# 8.3, 9.3, 0.3), отримати (0.3, 8.3, 6.3, 4.3, 2.3). Результат збережіть в нову змінну та
# виведіть на екран.
print("--------------------16-----------------")
original_tuple = (1.2, 2.3, 3.3, 4.3, 5.3, 6.3, 7.3, 8.3, 9.3, 0.3)
result_tuple = original_tuple[::-2]
print("Original Tuple:", original_tuple)
print("Result Tuple:", result_tuple)
#17. Створити множину без елементів. Після цого за допомогою методу додайте кілька різних елементів
# до множини. Чи множини є змінним типом даних?
print("--------------------17-----------------")
empty_set = set()
empty_set.add(5)
empty_set.add(10)
empty_set.add('hello')
print("17. Set:", empty_set)

# Відповідь: Множини є змінним типом даних.
#18. Створити множину, маючи список my_list = [1, 1, 2, 67, 67, 8, 9].
# Пояснити, чому "зникли" деякі елементи.
print("--------------------18-----------------")
my_list = [1, 1, 2, 67, 67, 8, 9]
unique_set = set(my_list)
print("18. Unique Set:", unique_set)
# Відповідь: У множині зникають дубльовані значення, оскільки вона містить лише унікальні елементи.

#19. Створіть дві множини. Продемонстуйте над ними операції: обʼєднання, різниці,
# пересічі та симетричної різниці. Використовуйте методи, що не змінюють множини,
# а створюють нові.
print("--------------------19-----------------")
set_a = {1, 2, 3, 4, 5}
set_b = {3, 4, 5, 6, 7}
print("Union Result:", set_a.union(set_b))
print("Difference Result:", set_a.difference(set_b))
print("Intersection Result:", set_a.intersection(set_b))
print("Symmetric Difference Result:", set_a.symmetric_difference(set_b))

#20. Створіть пустий словник. До нього додайте чотири пари елементів такі, щоб їхні ключі були
# різних типів. Чи може список бути ключем? Чому?
print("--------------------20-----------------")
dictionnary = {}
dictionnary[42] = 'integer key'
dictionnary['key'] = 'string key'
dictionnary[3.14] = 'float key'
dictionnary[True] = 'boolean key'
print("Dictionary:", dictionnary)
# Відповідь: Список не може бути ключем у словнику, оскільки ключі повинні бути хешованими, а списки - нехешованими.

#21. Створіть словник, де значенням в одній з пар теж буде словник, який теж має вкладений
# словник. Виведіть на екран значення, що міститься в словнику, що знаходиться на найнижчому
# рівні ієрархії вкладеності (найбільш внутрішній).
print("--------------------21-----------------")
# Створення словника з вкладеними словниками та додаванням більше значень
nested_dict = {'outer_key': {'inner_key': {'innermost_key': 'final_value', 'additional_key': 'extra_value'}}}

# Виведення всіх значень за допомогою вбудованої функції values()
print("All Nested Dictionary Values:")
for value in nested_dict['outer_key']['inner_key'].values():
    print(f"   Value: {value}")

